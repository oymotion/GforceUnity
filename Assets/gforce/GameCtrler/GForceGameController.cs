///////////////////////////////////////////////////////////
//  GForceGameController.cs
//  Implementation of the Class GForceGameController
//  Generated by Enterprise Architect
//  Created on:      02-2æœˆ-2021 16:07:33
//  Original author: hebin
///////////////////////////////////////////////////////////

using gf;
using GForce;
using System;
using System.Collections.Generic;
using System.Numerics;

namespace GameCtrler
{
    public class GForceGameController : GForceDevice, IGameController
    {
        public enum InternalState : int
        {
            STATUS_DISCONNECTED,
            STATUS_CONNECTED,
            STATUS_EMG_CONFIG_PENDING,
            STATUS_EMG_CONFIG_IN_PROGRESS,
            STATUS_EMG_CONFIG_ERROR,
            STATUS_EMG_CONFIG_FINISHED,
            STATUS_DATA_SWITCH_PENDING,
            STATUS_DATA_SWITCH_IN_PROGRESS,
            STATUS_DATA_SWITCH_ERROR,
            STATUS_DATA_SWITCH_FINISHED,
            STATUS_IDLE

        }//end InternalState

        class InputMap
        {
            public DataSource dataSource;
            public int subDataSource;
            public float min;
            public float max;

            public InputMap(DataSource dataSource, int subDataSource, float min, float max)
            {
                this.dataSource = dataSource;
                this.subDataSource = subDataSource;
                this.min = min;
                this.max = max;
            }
        }

        class ADCData
        {
            private const int LONG_TERM_MEAN_COEF = 2048;

            class SmoothBuffer
            {
                private int maxCount = 64;
                private float sum = 0;

                List<float> values = new List<float>();

                public void Init(int maxCount)
                {
                    this.maxCount = maxCount;
                    this.sum = 0;
                }

                public void Append(float value)
                {
                    values.Add(value);
                    sum += value;

                    if (values.Count > maxCount)
                    {
                        float oldValue = values[0];

                        values.RemoveAt(0);
                        sum -= oldValue;
                    }
                }

                public float GetMeanValue()
                {
                    if (values.Count == 0)
                        return 0;
                    else
                        return sum / values.Count;
                }
            }

            public void Init(int initialDCValue, int smoothBufferCntEMG, int smoothBufferCntRaw)
            {
                longTermMeanValue = initialDCValue;

                if (smoothBufferEMG == null)
                {
                    smoothBufferEMG = new SmoothBuffer();
                }

                smoothBufferEMG.Init(smoothBufferCntEMG);

                valueRaw = 0.0f;
            }

            public void Append(int value)
            {
                if (smoothBufferEMG != null)
                {
                    longTermMeanValue = (longTermMeanValue * (LONG_TERM_MEAN_COEF - 1) + value) / LONG_TERM_MEAN_COEF;

                    float acValue = value - longTermMeanValue;

                    smoothBufferEMG.Append(Math.Abs(acValue));
                }

                valueRaw = value;
            }

            public float GetEMGValue()
            {
                return (smoothBufferEMG == null) ? 0 : smoothBufferEMG.GetMeanValue();
            }

            public float GetRawValue()
            {
                return valueRaw;
            }

            private float valueRaw;
            private float longTermMeanValue;
            private SmoothBuffer smoothBufferEMG;
        }


        private Dictionary<int/*channel*/, ADCData> adcChannelsData = new Dictionary<int, ADCData>();

        private Dictionary<InputId, InputMap> inputMap = new Dictionary<InputId, InputMap>();

        private long _inputResetTime = -1;

        private byte[] adcData;


        ~GForceGameController()
        {

        }

        public GForceGameController()
        {

        }

        public float GetQuaternionX()
        {
            return GetQuaternion().X;
        }

        public float GetQuaternionY()
        {
            return GetQuaternion().Y;
        }
        public float GetQuaternionZ()
        {
            return GetQuaternion().Z;
        }

        public float GetQuaternionW()
        {
            return GetQuaternion().W;
        }

        public string GetName()
        {
            return (GetDevice() == null) ? "" : GetDevice().getName();
        }

        public ControllerState GetStatus()
        {
            ControllerState state = ControllerState.STATE_DISCONNECTED;

            switch (GetDeviceState())
            {
                case GForceDeviceState.STATE_DISCONNECTED:
                    state = ControllerState.STATE_DISCONNECTED;
                    break;

                case GForceDeviceState.STATE_DISCONNECTING:
                    state = ControllerState.STATE_DISCONNECTING;
                    break;

                case GForceDeviceState.STATE_CONNECTING:
                    state = ControllerState.STATE_CONNECTING;
                    break;

                case GForceDeviceState.STATE_CONNECTED:
                    state = ControllerState.STATE_CONNECTED;
                    break;

                case GForceDeviceState.STATE_READY:
                    state = ControllerState.STATE_READY;
                    break;
            }

            return state;
        }

        public void Tick()
        {
            if (_inputResetTime > 0 && GetTimeInMilliseconds() - _inputResetTime > 200)
            {
                _inputResetTime = -1;
            }

            TickGForce();
        }

        public override void UpdateEMGData(byte[] emgData)
        {
            base.UpdateEMGData(emgData);

            adcData = emgData;
            _lastEMGDataTime = GetTimeInMilliseconds();
        }

        public byte[] GetEmgValue()
        {
            lock (this)
            {
                return adcData;
            }
        }

        private float Map(float x, float in_min, float in_max, float out_min, float out_max)
        {
            return ((x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min);
        }

        private float Clamp(float value, float min, float max)
        {
            if (value < min) value = min;
            else if (value > max) value = max;
            return value;
        }

        private long GetTimeInMilliseconds()
        {
            return DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;
        }

    }//end GForceGameController

}//end namespace GameCtrler